// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class MarketCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save MarketCreated entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MarketCreated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MarketCreated", id.toString(), this);
  }

  static load(id: string): MarketCreated | null {
    return store.get("MarketCreated", id) as MarketCreated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get topic(): Bytes {
    let value = this.get("topic");
    return value.toBytes();
  }

  set topic(value: Bytes) {
    this.set("topic", Value.fromBytes(value));
  }

  get description(): string {
    let value = this.get("description");
    return value.toString();
  }

  set description(value: string) {
    this.set("description", Value.fromString(value));
  }

  get extraInfo(): string {
    let value = this.get("extraInfo");
    return value.toString();
  }

  set extraInfo(value: string) {
    this.set("extraInfo", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get marketCreator(): Bytes {
    let value = this.get("marketCreator");
    return value.toBytes();
  }

  set marketCreator(value: Bytes) {
    this.set("marketCreator", Value.fromBytes(value));
  }

  get outcomes(): Array<Bytes | null> {
    let value = this.get("outcomes");
    return value.toBytesArray();
  }

  set outcomes(value: Array<Bytes | null>) {
    this.set("outcomes", Value.fromBytesArray(value));
  }

  get marketCreationFee(): BigInt {
    let value = this.get("marketCreationFee");
    return value.toBigInt();
  }

  set marketCreationFee(value: BigInt) {
    this.set("marketCreationFee", Value.fromBigInt(value));
  }

  get minPrice(): BigInt {
    let value = this.get("minPrice");
    return value.toBigInt();
  }

  set minPrice(value: BigInt) {
    this.set("minPrice", Value.fromBigInt(value));
  }

  get maxPrice(): BigInt {
    let value = this.get("maxPrice");
    return value.toBigInt();
  }

  set maxPrice(value: BigInt) {
    this.set("maxPrice", Value.fromBigInt(value));
  }

  get marketType(): i32 {
    let value = this.get("marketType");
    return value.toI32();
  }

  set marketType(value: i32) {
    this.set("marketType", Value.fromI32(value));
  }
}

export class InitialReportSubmitted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save InitialReportSubmitted entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save InitialReportSubmitted entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("InitialReportSubmitted", id.toString(), this);
  }

  static load(id: string): InitialReportSubmitted | null {
    return store.get(
      "InitialReportSubmitted",
      id
    ) as InitialReportSubmitted | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get reporter(): Bytes {
    let value = this.get("reporter");
    return value.toBytes();
  }

  set reporter(value: Bytes) {
    this.set("reporter", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get amountStaked(): BigInt {
    let value = this.get("amountStaked");
    return value.toBigInt();
  }

  set amountStaked(value: BigInt) {
    this.set("amountStaked", Value.fromBigInt(value));
  }

  get isDesignatedReporter(): boolean {
    let value = this.get("isDesignatedReporter");
    return value.toBoolean();
  }

  set isDesignatedReporter(value: boolean) {
    this.set("isDesignatedReporter", Value.fromBoolean(value));
  }

  get payoutNumerators(): Array<BigInt | null> {
    let value = this.get("payoutNumerators");
    return value.toBigIntArray();
  }

  set payoutNumerators(value: Array<BigInt | null>) {
    this.set("payoutNumerators", Value.fromBigIntArray(value));
  }

  get invalid(): boolean {
    let value = this.get("invalid");
    return value.toBoolean();
  }

  set invalid(value: boolean) {
    this.set("invalid", Value.fromBoolean(value));
  }
}

export class DisputeCrowdsourcerCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save DisputeCrowdsourcerCreated entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save DisputeCrowdsourcerCreated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("DisputeCrowdsourcerCreated", id.toString(), this);
  }

  static load(id: string): DisputeCrowdsourcerCreated | null {
    return store.get(
      "DisputeCrowdsourcerCreated",
      id
    ) as DisputeCrowdsourcerCreated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get disputeCrowdsourcer(): Bytes {
    let value = this.get("disputeCrowdsourcer");
    return value.toBytes();
  }

  set disputeCrowdsourcer(value: Bytes) {
    this.set("disputeCrowdsourcer", Value.fromBytes(value));
  }

  get payoutNumerators(): Array<BigInt | null> {
    let value = this.get("payoutNumerators");
    return value.toBigIntArray();
  }

  set payoutNumerators(value: Array<BigInt | null>) {
    this.set("payoutNumerators", Value.fromBigIntArray(value));
  }

  get size(): BigInt {
    let value = this.get("size");
    return value.toBigInt();
  }

  set size(value: BigInt) {
    this.set("size", Value.fromBigInt(value));
  }

  get invalid(): boolean {
    let value = this.get("invalid");
    return value.toBoolean();
  }

  set invalid(value: boolean) {
    this.set("invalid", Value.fromBoolean(value));
  }
}

export class DisputeCrowdsourcerContribution extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save DisputeCrowdsourcerContribution entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save DisputeCrowdsourcerContribution entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("DisputeCrowdsourcerContribution", id.toString(), this);
  }

  static load(id: string): DisputeCrowdsourcerContribution | null {
    return store.get(
      "DisputeCrowdsourcerContribution",
      id
    ) as DisputeCrowdsourcerContribution | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get reporter(): Bytes {
    let value = this.get("reporter");
    return value.toBytes();
  }

  set reporter(value: Bytes) {
    this.set("reporter", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get disputeCrowdsourcer(): Bytes {
    let value = this.get("disputeCrowdsourcer");
    return value.toBytes();
  }

  set disputeCrowdsourcer(value: Bytes) {
    this.set("disputeCrowdsourcer", Value.fromBytes(value));
  }

  get amountStaked(): BigInt {
    let value = this.get("amountStaked");
    return value.toBigInt();
  }

  set amountStaked(value: BigInt) {
    this.set("amountStaked", Value.fromBigInt(value));
  }
}

export class DisputeCrowdsourcerCompleted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save DisputeCrowdsourcerCompleted entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save DisputeCrowdsourcerCompleted entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("DisputeCrowdsourcerCompleted", id.toString(), this);
  }

  static load(id: string): DisputeCrowdsourcerCompleted | null {
    return store.get(
      "DisputeCrowdsourcerCompleted",
      id
    ) as DisputeCrowdsourcerCompleted | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get disputeCrowdsourcer(): Bytes {
    let value = this.get("disputeCrowdsourcer");
    return value.toBytes();
  }

  set disputeCrowdsourcer(value: Bytes) {
    this.set("disputeCrowdsourcer", Value.fromBytes(value));
  }
}

export class InitialReporterRedeemed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save InitialReporterRedeemed entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save InitialReporterRedeemed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("InitialReporterRedeemed", id.toString(), this);
  }

  static load(id: string): InitialReporterRedeemed | null {
    return store.get(
      "InitialReporterRedeemed",
      id
    ) as InitialReporterRedeemed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get reporter(): Bytes {
    let value = this.get("reporter");
    return value.toBytes();
  }

  set reporter(value: Bytes) {
    this.set("reporter", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get amountRedeemed(): BigInt {
    let value = this.get("amountRedeemed");
    return value.toBigInt();
  }

  set amountRedeemed(value: BigInt) {
    this.set("amountRedeemed", Value.fromBigInt(value));
  }

  get repReceived(): BigInt {
    let value = this.get("repReceived");
    return value.toBigInt();
  }

  set repReceived(value: BigInt) {
    this.set("repReceived", Value.fromBigInt(value));
  }

  get reportingFeesReceived(): BigInt {
    let value = this.get("reportingFeesReceived");
    return value.toBigInt();
  }

  set reportingFeesReceived(value: BigInt) {
    this.set("reportingFeesReceived", Value.fromBigInt(value));
  }

  get payoutNumerators(): Array<BigInt | null> {
    let value = this.get("payoutNumerators");
    return value.toBigIntArray();
  }

  set payoutNumerators(value: Array<BigInt | null>) {
    this.set("payoutNumerators", Value.fromBigIntArray(value));
  }
}

export class DisputeCrowdsourcerRedeemed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save DisputeCrowdsourcerRedeemed entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save DisputeCrowdsourcerRedeemed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("DisputeCrowdsourcerRedeemed", id.toString(), this);
  }

  static load(id: string): DisputeCrowdsourcerRedeemed | null {
    return store.get(
      "DisputeCrowdsourcerRedeemed",
      id
    ) as DisputeCrowdsourcerRedeemed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get reporter(): Bytes {
    let value = this.get("reporter");
    return value.toBytes();
  }

  set reporter(value: Bytes) {
    this.set("reporter", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get disputeCrowdsourcer(): Bytes {
    let value = this.get("disputeCrowdsourcer");
    return value.toBytes();
  }

  set disputeCrowdsourcer(value: Bytes) {
    this.set("disputeCrowdsourcer", Value.fromBytes(value));
  }

  get amountRedeemed(): BigInt {
    let value = this.get("amountRedeemed");
    return value.toBigInt();
  }

  set amountRedeemed(value: BigInt) {
    this.set("amountRedeemed", Value.fromBigInt(value));
  }

  get repReceived(): BigInt {
    let value = this.get("repReceived");
    return value.toBigInt();
  }

  set repReceived(value: BigInt) {
    this.set("repReceived", Value.fromBigInt(value));
  }

  get reportingFeesReceived(): BigInt {
    let value = this.get("reportingFeesReceived");
    return value.toBigInt();
  }

  set reportingFeesReceived(value: BigInt) {
    this.set("reportingFeesReceived", Value.fromBigInt(value));
  }

  get payoutNumerators(): Array<BigInt | null> {
    let value = this.get("payoutNumerators");
    return value.toBigIntArray();
  }

  set payoutNumerators(value: Array<BigInt | null>) {
    this.set("payoutNumerators", Value.fromBigIntArray(value));
  }
}

export class ReportingParticipantDisavowed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ReportingParticipantDisavowed entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ReportingParticipantDisavowed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ReportingParticipantDisavowed", id.toString(), this);
  }

  static load(id: string): ReportingParticipantDisavowed | null {
    return store.get(
      "ReportingParticipantDisavowed",
      id
    ) as ReportingParticipantDisavowed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get reportingParticipant(): Bytes {
    let value = this.get("reportingParticipant");
    return value.toBytes();
  }

  set reportingParticipant(value: Bytes) {
    this.set("reportingParticipant", Value.fromBytes(value));
  }
}

export class MarketParticipantsDisavowed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save MarketParticipantsDisavowed entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MarketParticipantsDisavowed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MarketParticipantsDisavowed", id.toString(), this);
  }

  static load(id: string): MarketParticipantsDisavowed | null {
    return store.get(
      "MarketParticipantsDisavowed",
      id
    ) as MarketParticipantsDisavowed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }
}

export class FeeWindowRedeemed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save FeeWindowRedeemed entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save FeeWindowRedeemed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("FeeWindowRedeemed", id.toString(), this);
  }

  static load(id: string): FeeWindowRedeemed | null {
    return store.get("FeeWindowRedeemed", id) as FeeWindowRedeemed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get reporter(): Bytes {
    let value = this.get("reporter");
    return value.toBytes();
  }

  set reporter(value: Bytes) {
    this.set("reporter", Value.fromBytes(value));
  }

  get feeWindow(): Bytes {
    let value = this.get("feeWindow");
    return value.toBytes();
  }

  set feeWindow(value: Bytes) {
    this.set("feeWindow", Value.fromBytes(value));
  }

  get amountRedeemed(): BigInt {
    let value = this.get("amountRedeemed");
    return value.toBigInt();
  }

  set amountRedeemed(value: BigInt) {
    this.set("amountRedeemed", Value.fromBigInt(value));
  }

  get reportingFeesReceived(): BigInt {
    let value = this.get("reportingFeesReceived");
    return value.toBigInt();
  }

  set reportingFeesReceived(value: BigInt) {
    this.set("reportingFeesReceived", Value.fromBigInt(value));
  }
}

export class MarketFinalized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save MarketFinalized entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MarketFinalized entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MarketFinalized", id.toString(), this);
  }

  static load(id: string): MarketFinalized | null {
    return store.get("MarketFinalized", id) as MarketFinalized | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }
}

export class MarketMigrated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save MarketMigrated entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MarketMigrated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MarketMigrated", id.toString(), this);
  }

  static load(id: string): MarketMigrated | null {
    return store.get("MarketMigrated", id) as MarketMigrated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get originalUniverse(): Bytes {
    let value = this.get("originalUniverse");
    return value.toBytes();
  }

  set originalUniverse(value: Bytes) {
    this.set("originalUniverse", Value.fromBytes(value));
  }

  get newUniverse(): Bytes {
    let value = this.get("newUniverse");
    return value.toBytes();
  }

  set newUniverse(value: Bytes) {
    this.set("newUniverse", Value.fromBytes(value));
  }
}

export class UniverseForked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save UniverseForked entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniverseForked entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniverseForked", id.toString(), this);
  }

  static load(id: string): UniverseForked | null {
    return store.get("UniverseForked", id) as UniverseForked | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }
}

export class UniverseCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save UniverseCreated entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniverseCreated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniverseCreated", id.toString(), this);
  }

  static load(id: string): UniverseCreated | null {
    return store.get("UniverseCreated", id) as UniverseCreated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get parentUniverse(): Bytes {
    let value = this.get("parentUniverse");
    return value.toBytes();
  }

  set parentUniverse(value: Bytes) {
    this.set("parentUniverse", Value.fromBytes(value));
  }

  get childUniverse(): Bytes {
    let value = this.get("childUniverse");
    return value.toBytes();
  }

  set childUniverse(value: Bytes) {
    this.set("childUniverse", Value.fromBytes(value));
  }

  get payoutNumerators(): Array<BigInt | null> {
    let value = this.get("payoutNumerators");
    return value.toBigIntArray();
  }

  set payoutNumerators(value: Array<BigInt | null>) {
    this.set("payoutNumerators", Value.fromBigIntArray(value));
  }

  get invalid(): boolean {
    let value = this.get("invalid");
    return value.toBoolean();
  }

  set invalid(value: boolean) {
    this.set("invalid", Value.fromBoolean(value));
  }
}

export class OrderCanceled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save OrderCanceled entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save OrderCanceled entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("OrderCanceled", id.toString(), this);
  }

  static load(id: string): OrderCanceled | null {
    return store.get("OrderCanceled", id) as OrderCanceled | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get shareToken(): Bytes {
    let value = this.get("shareToken");
    return value.toBytes();
  }

  set shareToken(value: Bytes) {
    this.set("shareToken", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get orderId(): Bytes {
    let value = this.get("orderId");
    return value.toBytes();
  }

  set orderId(value: Bytes) {
    this.set("orderId", Value.fromBytes(value));
  }

  get orderType(): i32 {
    let value = this.get("orderType");
    return value.toI32();
  }

  set orderType(value: i32) {
    this.set("orderType", Value.fromI32(value));
  }

  get tokenRefund(): BigInt {
    let value = this.get("tokenRefund");
    return value.toBigInt();
  }

  set tokenRefund(value: BigInt) {
    this.set("tokenRefund", Value.fromBigInt(value));
  }

  get sharesRefund(): BigInt {
    let value = this.get("sharesRefund");
    return value.toBigInt();
  }

  set sharesRefund(value: BigInt) {
    this.set("sharesRefund", Value.fromBigInt(value));
  }
}

export class OrderCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save OrderCreated entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save OrderCreated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("OrderCreated", id.toString(), this);
  }

  static load(id: string): OrderCreated | null {
    return store.get("OrderCreated", id) as OrderCreated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get orderType(): i32 {
    let value = this.get("orderType");
    return value.toI32();
  }

  set orderType(value: i32) {
    this.set("orderType", Value.fromI32(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get price(): BigInt {
    let value = this.get("price");
    return value.toBigInt();
  }

  set price(value: BigInt) {
    this.set("price", Value.fromBigInt(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    return value.toBytes();
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get moneyEscrowed(): BigInt {
    let value = this.get("moneyEscrowed");
    return value.toBigInt();
  }

  set moneyEscrowed(value: BigInt) {
    this.set("moneyEscrowed", Value.fromBigInt(value));
  }

  get sharesEscrowed(): BigInt {
    let value = this.get("sharesEscrowed");
    return value.toBigInt();
  }

  set sharesEscrowed(value: BigInt) {
    this.set("sharesEscrowed", Value.fromBigInt(value));
  }

  get tradeGroupId(): Bytes {
    let value = this.get("tradeGroupId");
    return value.toBytes();
  }

  set tradeGroupId(value: Bytes) {
    this.set("tradeGroupId", Value.fromBytes(value));
  }

  get orderId(): Bytes {
    let value = this.get("orderId");
    return value.toBytes();
  }

  set orderId(value: Bytes) {
    this.set("orderId", Value.fromBytes(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get shareToken(): Bytes {
    let value = this.get("shareToken");
    return value.toBytes();
  }

  set shareToken(value: Bytes) {
    this.set("shareToken", Value.fromBytes(value));
  }
}

export class OrderFilled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save OrderFilled entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save OrderFilled entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("OrderFilled", id.toString(), this);
  }

  static load(id: string): OrderFilled | null {
    return store.get("OrderFilled", id) as OrderFilled | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get shareToken(): Bytes {
    let value = this.get("shareToken");
    return value.toBytes();
  }

  set shareToken(value: Bytes) {
    this.set("shareToken", Value.fromBytes(value));
  }

  get filler(): Bytes {
    let value = this.get("filler");
    return value.toBytes();
  }

  set filler(value: Bytes) {
    this.set("filler", Value.fromBytes(value));
  }

  get orderId(): Bytes {
    let value = this.get("orderId");
    return value.toBytes();
  }

  set orderId(value: Bytes) {
    this.set("orderId", Value.fromBytes(value));
  }

  get numCreatorShares(): BigInt {
    let value = this.get("numCreatorShares");
    return value.toBigInt();
  }

  set numCreatorShares(value: BigInt) {
    this.set("numCreatorShares", Value.fromBigInt(value));
  }

  get numCreatorTokens(): BigInt {
    let value = this.get("numCreatorTokens");
    return value.toBigInt();
  }

  set numCreatorTokens(value: BigInt) {
    this.set("numCreatorTokens", Value.fromBigInt(value));
  }

  get numFillerShares(): BigInt {
    let value = this.get("numFillerShares");
    return value.toBigInt();
  }

  set numFillerShares(value: BigInt) {
    this.set("numFillerShares", Value.fromBigInt(value));
  }

  get numFillerTokens(): BigInt {
    let value = this.get("numFillerTokens");
    return value.toBigInt();
  }

  set numFillerTokens(value: BigInt) {
    this.set("numFillerTokens", Value.fromBigInt(value));
  }

  get marketCreatorFees(): BigInt {
    let value = this.get("marketCreatorFees");
    return value.toBigInt();
  }

  set marketCreatorFees(value: BigInt) {
    this.set("marketCreatorFees", Value.fromBigInt(value));
  }

  get reporterFees(): BigInt {
    let value = this.get("reporterFees");
    return value.toBigInt();
  }

  set reporterFees(value: BigInt) {
    this.set("reporterFees", Value.fromBigInt(value));
  }

  get amountFilled(): BigInt {
    let value = this.get("amountFilled");
    return value.toBigInt();
  }

  set amountFilled(value: BigInt) {
    this.set("amountFilled", Value.fromBigInt(value));
  }

  get tradeGroupId(): Bytes {
    let value = this.get("tradeGroupId");
    return value.toBytes();
  }

  set tradeGroupId(value: Bytes) {
    this.set("tradeGroupId", Value.fromBytes(value));
  }
}

export class CompleteSetsPurchased extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompleteSetsPurchased entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompleteSetsPurchased entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompleteSetsPurchased", id.toString(), this);
  }

  static load(id: string): CompleteSetsPurchased | null {
    return store.get(
      "CompleteSetsPurchased",
      id
    ) as CompleteSetsPurchased | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get numCompleteSets(): BigInt {
    let value = this.get("numCompleteSets");
    return value.toBigInt();
  }

  set numCompleteSets(value: BigInt) {
    this.set("numCompleteSets", Value.fromBigInt(value));
  }
}

export class CompleteSetsSold extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save CompleteSetsSold entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompleteSetsSold entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompleteSetsSold", id.toString(), this);
  }

  static load(id: string): CompleteSetsSold | null {
    return store.get("CompleteSetsSold", id) as CompleteSetsSold | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get numCompleteSets(): BigInt {
    let value = this.get("numCompleteSets");
    return value.toBigInt();
  }

  set numCompleteSets(value: BigInt) {
    this.set("numCompleteSets", Value.fromBigInt(value));
  }
}

export class TradingProceedsClaimed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save TradingProceedsClaimed entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save TradingProceedsClaimed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("TradingProceedsClaimed", id.toString(), this);
  }

  static load(id: string): TradingProceedsClaimed | null {
    return store.get(
      "TradingProceedsClaimed",
      id
    ) as TradingProceedsClaimed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get shareToken(): Bytes {
    let value = this.get("shareToken");
    return value.toBytes();
  }

  set shareToken(value: Bytes) {
    this.set("shareToken", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get numShares(): BigInt {
    let value = this.get("numShares");
    return value.toBigInt();
  }

  set numShares(value: BigInt) {
    this.set("numShares", Value.fromBigInt(value));
  }

  get numPayoutTokens(): BigInt {
    let value = this.get("numPayoutTokens");
    return value.toBigInt();
  }

  set numPayoutTokens(value: BigInt) {
    this.set("numPayoutTokens", Value.fromBigInt(value));
  }

  get finalTokenBalance(): BigInt {
    let value = this.get("finalTokenBalance");
    return value.toBigInt();
  }

  set finalTokenBalance(value: BigInt) {
    this.set("finalTokenBalance", Value.fromBigInt(value));
  }
}

export class TokensTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save TokensTransferred entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save TokensTransferred entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("TokensTransferred", id.toString(), this);
  }

  static load(id: string): TokensTransferred | null {
    return store.get("TokensTransferred", id) as TokensTransferred | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get tokenType(): i32 {
    let value = this.get("tokenType");
    return value.toI32();
  }

  set tokenType(value: i32) {
    this.set("tokenType", Value.fromI32(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }
}

export class TokensMinted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save TokensMinted entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save TokensMinted entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("TokensMinted", id.toString(), this);
  }

  static load(id: string): TokensMinted | null {
    return store.get("TokensMinted", id) as TokensMinted | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    return value.toBytes();
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get tokenType(): i32 {
    let value = this.get("tokenType");
    return value.toI32();
  }

  set tokenType(value: i32) {
    this.set("tokenType", Value.fromI32(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }
}

export class TokensBurned extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save TokensBurned entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save TokensBurned entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("TokensBurned", id.toString(), this);
  }

  static load(id: string): TokensBurned | null {
    return store.get("TokensBurned", id) as TokensBurned | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    return value.toBytes();
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get tokenType(): i32 {
    let value = this.get("tokenType");
    return value.toI32();
  }

  set tokenType(value: i32) {
    this.set("tokenType", Value.fromI32(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }
}

export class FeeWindowCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save FeeWindowCreated entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save FeeWindowCreated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("FeeWindowCreated", id.toString(), this);
  }

  static load(id: string): FeeWindowCreated | null {
    return store.get("FeeWindowCreated", id) as FeeWindowCreated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get feeWindow(): Bytes {
    let value = this.get("feeWindow");
    return value.toBytes();
  }

  set feeWindow(value: Bytes) {
    this.set("feeWindow", Value.fromBytes(value));
  }

  get startTime(): BigInt {
    let value = this.get("startTime");
    return value.toBigInt();
  }

  set startTime(value: BigInt) {
    this.set("startTime", Value.fromBigInt(value));
  }

  get endTime(): BigInt {
    let value = this.get("endTime");
    return value.toBigInt();
  }

  set endTime(value: BigInt) {
    this.set("endTime", Value.fromBigInt(value));
  }

  get id(): BigInt {
    let value = this.get("id");
    return value.toBigInt();
  }

  set id(value: BigInt) {
    this.set("id", Value.fromBigInt(value));
  }
}

export class InitialReporterTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save InitialReporterTransferred entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save InitialReporterTransferred entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("InitialReporterTransferred", id.toString(), this);
  }

  static load(id: string): InitialReporterTransferred | null {
    return store.get(
      "InitialReporterTransferred",
      id
    ) as InitialReporterTransferred | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }
}

export class MarketTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save MarketTransferred entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MarketTransferred entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MarketTransferred", id.toString(), this);
  }

  static load(id: string): MarketTransferred | null {
    return store.get("MarketTransferred", id) as MarketTransferred | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }
}

export class MarketMailboxTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save MarketMailboxTransferred entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MarketMailboxTransferred entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MarketMailboxTransferred", id.toString(), this);
  }

  static load(id: string): MarketMailboxTransferred | null {
    return store.get(
      "MarketMailboxTransferred",
      id
    ) as MarketMailboxTransferred | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get universe(): Bytes {
    let value = this.get("universe");
    return value.toBytes();
  }

  set universe(value: Bytes) {
    this.set("universe", Value.fromBytes(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get mailbox(): Bytes {
    let value = this.get("mailbox");
    return value.toBytes();
  }

  set mailbox(value: Bytes) {
    this.set("mailbox", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }
}

export class EscapeHatchChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save EscapeHatchChanged entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save EscapeHatchChanged entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("EscapeHatchChanged", id.toString(), this);
  }

  static load(id: string): EscapeHatchChanged | null {
    return store.get("EscapeHatchChanged", id) as EscapeHatchChanged | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get isOn(): boolean {
    let value = this.get("isOn");
    return value.toBoolean();
  }

  set isOn(value: boolean) {
    this.set("isOn", Value.fromBoolean(value));
  }
}

export class TimestampSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save TimestampSet entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save TimestampSet entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("TimestampSet", id.toString(), this);
  }

  static load(id: string): TimestampSet | null {
    return store.get("TimestampSet", id) as TimestampSet | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get newTimestamp(): BigInt {
    let value = this.get("newTimestamp");
    return value.toBigInt();
  }

  set newTimestamp(value: BigInt) {
    this.set("newTimestamp", Value.fromBigInt(value));
  }
}
